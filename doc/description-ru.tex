\documentclass[russian,12pt,a4paper,titlepage]{article}

\usepackage[koi8-r]{inputenc}
\usepackage[russian]{babel}
\usepackage[dvips,left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage{textcomp}
\setlength\parskip{12pt}
\frenchspacing
\righthyphenmin=2

\author{Резиков Пётр}
\title{Обзор Emacs Rails}
\date{\today}

\newcommand{\file}[1]{{\bf #1}}

\newcommand{\code}[1]{{\bf #1}}

\begin{document}

\maketitle
\newpage
\tableofcontents
\newpage


% Установка

\section{О Emacs Rails}

Emacs Rails (он же rails-minor-mode, он же rails.el) (http://rubyforge.org/projects/emacs-rails/)
надстройка над редактором Emacs(http://www.gnu.org/software/emacs/) для работы с фрэймворком Ruby
On Rails (http://rubyonrails.com). Основная цель данной настройки автоматизировать рутинные
действия которые приходиться делать программисту во время разработки Rails-приложений. Проект
создан Дмитрием Галинским в начале 2006 года. И сейчас постоянно развивается, обрастая всё новыми
возможностями. В этом обзоре будут перечислены основные функции программы с примерами применения.

 
% Установка


\section{Возможности Emacs}

Emacs может по достоинству назваться самым функциональным редактором в мире, благодаря мощному
языку расширения Emacs Lisp вы можете быстро создавать расширения для редактирования чего угодно
и как угодно с любым уровнем автоматизации, а также использовать его как почтовый/IM клиент,
браузер и многое-многое другое. Но вернёмся к нашей теме. Сначала упомянем несколько полезных
функций Emacs не относящихся на прямую к Ruby или Rails.

\begin{enumerate}
\item Работа с большинством систем контроля версий.
\item Интеграция практически со всеми видами интерактивных консолей (irb, sql, shell и.т.д.)
\item TAGS которые позволяют вам переходить быстро между классами/функциями вашего проекта и
  автокомлит по ним же
\item Унифицированность интерфейса для работы практически со всем ПО, необходимым для
  разработчика
\item ``Тупой'' автокомлит -- очень удобная функция позволяющая раскрывать слово по самому
  близкому совпадению, т.е. часто при написание программы вы будите набирать только 1-2 буквы
  названия переменной/функции и нажимать M-/.
\item Прозрачная работа с удалёнными системами как с локальной.
\item Кросплатформенность (работает на всех известных и неизвестных:) системах)
\end{enumerate}

Фактически для работы с Rails нам
понадобятся несколько основных режимов Emacs, помимо Emacs Rails. Файл \file{ruby-mode.el}
(кстати написанный самим Matz) и другие идущие с ним файлы обеспечат вас:
\begin{enumerate}
\item Подсветкой синтаксиса
\item Очень хорошим авто-выравниванием
\item Интеграцией с интерактивной буфером руби, позволяющая посылать туда функции и блоки кода
  прямо из редактируемого файла
\item Отладчик ruby интегрированный с Emacs-интерфейсом отладки GUD
\end{enumerate}

Для редактирования html вам пригодиться html-mode или html-helper-mode, которые тоже поддерживают
авто-выравнивание, подсветку и автокомлит. Скорее всего пригодиться также sql-mode, для
редактирования SQL файлов и работы с SQL консолью. Режим MMM позволит вам работать с несколькими
режимами в одном файле, что чрезвычайно полезно при редактировании rhtml файлов. Также я бы
посоветовал сразу использовать режим ido позволяющий осуществлять быстрою навигацию между
буферами(открытыми файлами) и по файловой системе.

Отдельно можно отметить особенность Emacs Rails авто-определять находиться ли файлы в рельсовой
иерархии или нет. Т.е. вам не нужно включать специально rails-minor-mode или менять проект, просто
откройте нужный файл и Emacs Rails сам определит запускаться или нет.


\section{Snippets}

Snippets это один из видов т.н. аббревиатур -- сокращений разворачивающихся в какой-либо
стандартный код. В Emacs Rails встроено большое количество сниппов для основных компонентов Rails.
Для того чтобы сниппет заработал вам необходимо ввести аббревиатуру и нажать клавишу <TAB>, все
сниппеты документированы и в cгруппированном виде представлены в меню (через которое вы тоже можете
активизировать сниппет). Например введя \code{recai} и нажав <TAB> вы получите:

\begin{verbatim}
    redirect_to :controller => "items", :action => "show", :id => @item
\end{verbatim}

Курсор будет стоять на подсвеченном слове ``items'' и после ввода вашего значения взамен вы можете
перейти на следующее поле(в данном случае ``show'') нажав <TAB>, после последнего поля курсор
установиться на завершающую точку сниппа, часто это конец сгенерированного текста, но не всегда.
Просто нажав <TAB> на поле, не изменяя его, вы оставите поле в таком виде, как оно было задано в
шаблоне. Приведём ещё одни пример для rhtml файла. Набрав \code{\%ifel} и нажав <TAB> вы получите:

\begin{verbatim}
<% if cond -%>

<% else -%>
<% end -%>
\end{verbatim}


\subsection{Создание собственных сниппов}

Скорее всего вскоре после освоения сниппов вам захочется создавать собственные сниппы. Делается
это очень просто в ваш конфигурационный файл emacs (после загрузки пакета Emacs Rails) вы можете
вводить свои сниппы с помощью макроса def-snips. Пример:

\begin{verbatim}
(def-snips (html-mode-abbrev-table html-helper-mode-abbrev-table)            
  ("ft"      "<%= form_tag :action => \"$${update}\" %>\n$.\n<%= end_form_tag %>"
             "form_tag\t(ft)")
  ("lia"     "<%= link_to \"$${title}\", :action => \"$${index}\" %>"
             "link_to (action)\t(lia)")
  ("liai"    "<%= link_to \"$${title}\", :action => \"$${edit}\", :id => $${@item} %>"
             "link_to (action, id)\t(liai)")) 
\end{verbatim}

Здесь \code{html-mode-abbrev-table} и \code{html-helper-mode-abbrev-table}~-- это название
режимов в которых данные сниппы будут активны. В данном случае это две различных режимы для
работы с html в Emacs. Для ваших сниппов вам будет необходимо указать ваш режим для работы с
html в случае rhtml сниппов или ruby-mode-abbrev-table для работы с руби файлами, аналогично для
других режимов, например для SQL~-- sql-mode-abbrev-table. За указанием режимов следуют сами
сниппы. Каждый снипп заключен в круглые скобки с тремя полями~-- сокращение, шаблон развёртки и
документация. Вам скорей всего будет необходимо заполнять только первые два. С сокращением всё
понятно -- это тот текст после которого нажав <TAB> вы получите развёртку. Шаблон развёртки
представляет собой строку, в которой поля, заменяющиеся интерактивно после развёртки ограничены
символами: \code{\$\$\{\}}, также \code{\$.} является точкой останова, а \code{\$>} командой
авто-выравнивания. Подробнее смотрите документацию к \file{snippet.el}. Кроме макроса
\code{def-snip} вы можете использовать почти аналогичный, но не предусматривающий документации и
задания нескольких режимов макрос \code{snippet-with-abbrev-table}.


\section{Навигация}

Благодаря своей стандартной структуре файловый иерархии возможно хорошо автоматизировать функции
навигации между файлами.


\subsection{Переключение межу файлами  rails-goto-file-from-file}

Функция очень проста в использование (вызываться по клав. комбинации M-S-Up). Если вы находитесь
в контроллере, функция перемещает вас в файл view для action на котором стоит курсор. Если такого
файла не существует вы можете тут же автоматически создать его. Если таких файлов несколько
(foo.rhtml, foo.rjs) появиться меню, в котором можно будет выбрать нужный. Если же вы находитесь
в файле шаблона вызов команды переместит вас в контроллер на соответствующий action. Если вы
находитесь в моделе вы попадёте в unit тест модели, если в хелпере к соответствующему view
и.т.д. Но одному файлу может соответствовать несколько родственных, например для контроллера -- это
view, helper и functional-test, чтобы перейти на альтернативный родственный файл. Вызовите команду
rails-goto-file-from-file с префиксом, или команду rails-goto-file-from-file-with-menu по
комбинации M-S-down, тогда откроется меню с возможными вариантами перехода, где вы можете указать
необходимы файл и перейти на него. Можно отметить что меню может быть двух видов всплывающие е
текстовое, чтобы включить текстовое меню установите переменную \code{rails-use-text-menu} в \code{t}.


\subsection{Меню перехода на файлы}

Нажав C-c g X, где X это буква типа файла m - модели, с - контроллеры, h - хэлперы, l - слои, s - стили, j  - javascript файлы, g - миграции, вы увидите меню со всеми файлами в этой категории, кликнув на которое вы перейдёте в соответствующий файл.


\subsection{Интеграция с CTAGS - rails-create-tags}

Как уже говорилось ранее TAGS позволит вам осуществлять быструю навигацию по коду, а также
предоставит не очень сложный автокомплит. Для использования с ruby вам необходимо загрузить
программу генерации TAGS http://ctags.sourceforge.net, т.к идущая с Emacs etags не знает ничего о
ruby. Далее всё просто. Нажав C-c C-t(или щёлкнув на соответствующем пункте меню) произойдёт
генерация TAG'ов в корне вашего Rails проекта и они автоматически загрузятся в Emacs.  Возможно у
вас буду проблемы с параметрами командной строки ctags тогда вам нужно будет в ручную поправить код.
В следующей версии параметры ctags будут задаваться через переменную \code{rails-ctags-command}.
Теперь поставив курсор на название класса/метода и нажав М-. вы перейдёте на него. А клавиша
M-<TAB> произведёт автокомплит на основе TAG'ов. Подробнее о автокомплите навигации по TAG'ам
читайте документацию по Emacs. К сожалению TAGS не обновляется автоматически, поэтому вам
придётся перегружать её через определённое время (или написать скрипт для автоматической
генерации).


\subsection{Быстрая навигация в файловой иерархии Rails-finds }

В файловой иерархии Rails есть несколько каталогов, которые вы часто посещаете, для быстрого
доступа к этим каталогам и создан rails-finds. Нажав <<префикс>> + N, где <<префикс>> это
комбинация клавиш C-c C-f либо F2, а N -- это клавиша соответствующая определённому
каталогу:
\begin{itemize}
\item c -- app/controllers
\item m -- app/models
\item v -- app/views
\item l -- app/views/layouts
\item d -- db/
\item p -- public/
\item h -- app/helpers
\item o -- config/
\end{itemize}
вы запустите команду выбора файла в данном каталоге текущего проекта. 

Также можно быстро добавить дополнительный каталог примерно таким кодом в конфигурационном файле
Emacs:

\begin{verbatim}

(def-rails-find rails-find-foo-bar "foo/bar/")

(define-keys rails-minor-mode-map
  ((kbd "\C-c \C-f f") 'rails-find-foo-bar)
  ((kbd "<f2> f") 'rails-find-foo-bar))

\end{verbatim}

\file{foo/bar} -- каталог относительно корня текущего Rails проекта.



\subsection{Переход на файл в зависимости от строки }

Эта функция вызывается по C-return и переходит[D[D[D[D[Dходит в определённой файл в зависимости от строки. Для
большинства функций имеющих параметры :action и :controller эта функция будет переходить на
соответствующий action. Если она будет вызвана внутри контроллера то перейдёт к коду action'a, если
внутри views то к соответствующему ERb файлу. Но если функция будет вызвана с префиксом, то
произойдёт наоборот -- из контроллера вы попадёте в views из views в контроллер. Также эта функция
переходит на нужный layout если строка с указанием на него, либо на нужный partial, в случае render :partial. Вскоре будет добавлено гораздо больше правил для авто-перехода.


\subsection{Просмотр лог-файлов -- rails-open-log}

Нажав C-c l(или выбрав через меню) и выбрав имя environment'a вы получите в буфере Emacs
Rails-log с подсветкой, который будет автоматически обновляться по мере поступления новых
сообщений.



\subsection{Быстрый доступ к конфигурационным файлам -- rails-open-config}

Нажав C-c o или выбрав из меню можно открыть любой основной конфигурационный файл Rails.


\section{Рефакторинг ERb}

Две функции созданы для рефакторинга ERb файлов.


\subsection{Создание partial из выбранного региона -- rails-create-partial-from-selection}

Находясь в ERb файле выделите регион и нажмите C-c p. Введите названия файла partial (без подчёркивания в начале) и partial автоматически выделиться из данного региона и на месте региона появиться команда \code{render :paritial}, а в соседнем окне появиться файл partial.


\subsection{Создание хелпера из блока rails-create-helper-from-block}

Работает аналогично предыдущей функции, только создаёт не partial а helper. Запускается по C-c b.

\section{Генераторы/деструкторы }

Разработан общий интерфейс для работы с скриптами (script/create и script/destroy).



\subsection{Создание проекта rails-create-project}

Функция rails-create-project создаёт новый rails проект в указанном каталоге и отрывает этот
каталог в Emacs.

\subsection{Генераторы}

Для всех генераторов клавиатурный префикс -- С-с g (C-c s g) (не
забывайте также про меню), после которого следует клавиша m - для
модели, c - для контроллера, s - для scaffold и i для migration. После
чего будут запрошены параметры генерации, для каждого вида свои
(работает автокомлит, например при создании контроллера дополняются
уже созданные контроллеры-каталоги). Некоторые параметры можно
опустить. После этого информация о генерации будет выведена в буфер
*RailsGeneration* а в текущем буфере будет открыт генерированный
файл. Также вся информация записывается в файл
\file{RAILS\_ROOT/log/rails-minor-mode.log}.

\subsection{Деструкторы}

Интерфейс деструкторов аналогичен генераторам (клавишный префикс C-c d) автокомлит работает по всем
текущим созданным моделям/контроллерам.
        
\section{Прочее}

\subsection{Интеграция с http сервером}

С помощью меню вы можете управлять http сервером текущего проекта -- запустить сервер для
необходимого environment'a, остановить сервер а также вывести авто-обновляемый лог сервера или
открыть браузер. Также вы можете использовать Mongrel вместо Webrick, установив соответствующую
опцию в меню.


\subsection{Поиск по документации}

Функция  rails-search-doc (F1) позволит вам получить документацию по определённой функции, к
сожалению особо сказать ничего не могу так пользуюсь в основном html документацией.

\subsection{Интеграция с textmate backtracer }

В README файле описана интеграция с textmate backtracer, которая позволят кликнув мышкой в
браузере перейти на заданную строку в файле.


\subsection{Открытие браузера }

Находясь в контроллере или view и нажав C-c F5 вы откроете браузер для текущего action'a. Если
перед C-c набрать префикс C-u можно задать параметры для action'a. С-c C-x F5 вызывают функцию
rails-open-browser-on-controller которая попросит вас ввести/выбрать имя контроллера, action'a и
параметры и откроет браузер на необходимой странице.

\subsection{Автоматическое открытие SQL-сессии }

Нажав C-c C-z Emacs Rails определит параметры базы данных для текущего Rails проекта
(environment можно задать) и откроет sql буфер в этой БД. Если sql буфер уже открыт то команда
вызовет просто переход в этот буфер (даже если это будет буфер с другой SQL сессией - в таком
случае уничтожьте его).



\subsection{Интерактивные скрипты }

С-с z и С-с С-b запускают соответственно скрипты script/console и script/breakpointer для текущего
проекта в интерактивном буфере. К сожалению пока можно запускать только один интерактивный буфер
с ruby, но в скором будущем скрипты будут распределяться по буферам с именами типа
\code{*-ruby-project-name-breakpoiner*}.


\subsection{Subversion}

Функция rails-svn-status-into-root - С-с v открывает режим Emacs для работы с svn в корне
текущего проекта.

\subsection{Переход по ошибке}

Поскольку по тех. причинам я не пользуюсь textmate backtracer'ом написал функцию которая на основе
rails отчёта об ошибке переходит на строку с ошибкой в emacs'е. Необходим только, чтобы браузер мог
для исходника страницы запустить следующий скрипт (unix версия):
\begin{verbatim}
#!/bin/sh
# -*- sh -*-
#FvwmCommand "All (emacs) WarpToWindow 50 50"
gnudoit.emacs "(find-file \"$1\") (rails-find-and-goto-error)"
\end{verbatim}

Я делаю это с помощью расширения Firefox -- ViewSourceWith (http://dafizilla.sourceforge.net/viewsourcewith/).



\section{Смотрите также}

\begin{itemize}
\item http://wiki.rubyonrails.org/rails/pages/HowToUseEmacsWithRails
\item http://ror2ru.elementalcms.org/index.php?n=Main.EmacsInstallation
\end{itemize}

\end{document}
